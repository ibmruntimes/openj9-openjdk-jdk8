# ===========================================================================
# (c) Copyright IBM Corp. 2017, 2020 All Rights Reserved
# ===========================================================================
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.
#
# IBM designates this particular file as subject to the "Classpath" exception
# as provided by IBM in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, see <http://www.gnu.org/licenses/>.
# ===========================================================================

# spec.gmk is generated by configure and contains many of the variable definitions used in this makefile
ifeq (,$(wildcard $(SPEC)))
  $(error OpenJ9.gmk needs SPEC set to a proper spec.gmk)
endif
include $(SPEC)
include $(SRC_ROOT)/make/common/MakeBase.gmk

ifeq (,$(BUILD_ID))
  BUILD_ID := 000000
endif

OPENJ9_SHA := $(shell git -C $(OPENJ9_TOPDIR) rev-parse --short HEAD)
ifeq (,$(OPENJ9_SHA))
  $(error Could not determine OpenJ9 SHA)
endif

# Find OpenJ9 tag associated with current commit (suppressing stderr in case there is no such tag).
OPENJ9_TAG := $(shell git -C $(OPENJ9_TOPDIR) describe --exact-match HEAD 2>/dev/null)
ifeq (,$(OPENJ9_TAG))
  OPENJ9_BRANCH := $(shell git -C $(OPENJ9_TOPDIR) rev-parse --abbrev-ref HEAD)
  ifeq (,$(OPENJ9_BRANCH))
    $(error Could not determine OpenJ9 branch)
  endif
  OPENJ9_VERSION_STRING := $(OPENJ9_BRANCH)-$(OPENJ9_SHA)
else
  OPENJ9_VERSION_STRING := $(OPENJ9_TAG)
endif

OPENJ9OMR_SHA := $(shell git -C $(OPENJ9OMR_TOPDIR) rev-parse --short HEAD)
ifeq (,$(OPENJ9OMR_SHA))
  $(error Could not determine OMR SHA)
endif

OPENJ9_NOTICE_FILE := openj9/longabout.html
OPENJ9_NOTICE_FILE_RENAME := openj9-notices.html
OPENJ9_OPENJDK_NOTICE_FILE := openj9-openjdk-notices

# openjdk makeflags don't work with openj9/omr native compiles; override with number of CPUs which openj9 and omr need supplied
override MAKEFLAGS := -j $(JOBS)

ifeq (windows,$(OPENJDK_TARGET_OS))
  # convert unix path to windows path
  FixPath = $(shell $(CYGPATH) -m $1)
  # set Visual Studio environment
  EXPORT_MSVS_ENV_VARS := PATH="$(PATH)" INCLUDE="$(INCLUDE)" LIB="$(LIB)"
  # set the output directory for shared libraries
  OPENJ9_LIBS_OUTPUT_DIR := bin
else
  FixPath = $1
  EXPORT_MSVS_ENV_VARS :=
  OPENJ9_LIBS_OUTPUT_DIR := lib$(OPENJDK_TARGET_CPU_LIBDIR)
endif

.PHONY : \
	build-j9 \
	build-openj9-tools \
	clean-j9 \
	clean-j9-dist \
	clean-openj9-thirdparty-binaries \
	generate-j9jcl-sources \
	generate-j9-version-headers \
	run-preprocessors-j9 \
	stage-j9 \
	stage_openj9_build_jdk \
	#

define copy_and_sign
	$(call install-file)
	$(call CodesignFile,"$@")
endef

ifeq (true,$(OPENJ9_ENABLE_JITSERVER))
  # sign the jitserver executable as we copy it to bin
  $(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := copy_and_sign, \
	SRC := $(OPENJ9_VM_BUILD_DIR), \
	DEST := $(JDK_OUTPUTDIR)/bin, \
	FILES := jitserver$(EXE_SUFFIX) \
	))

  # copy the signed jitserver executable to jre/bin
  $(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := install-file, \
	SRC := $(JDK_OUTPUTDIR)/bin, \
	DEST := $(JDK_OUTPUTDIR)/jre/bin, \
	FILES := jitserver$(EXE_SUFFIX) \
	))
endif # OPENJ9_ENABLE_JITSERVER

# sign the redirector library as we copy it to j9vm
$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := copy_and_sign, \
	SRC := $(OPENJ9_VM_BUILD_DIR)/redirector, \
	DEST := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR)/j9vm, \
	FILES := $(call SHARED_LIBRARY,jvm) \
	))

# copy the signed redirector library to server
$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := install-file, \
	SRC := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR)/j9vm, \
	DEST := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR)/server, \
	FILES := $(call SHARED_LIBRARY,jvm) \
	))

# sign the jsig library as we copy it to lib
$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := copy_and_sign, \
	SRC := $(OPENJ9_VM_BUILD_DIR), \
	DEST := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR), \
	FILES := $(call SHARED_LIBRARY,jsig) \
	))

# copy the signed jsig library to j9vm and server directories
$(foreach subdir, j9vm server, \
	$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
		MACRO := install-file, \
		SRC := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR), \
		DEST := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR)/$(subdir), \
		FILES := $(call SHARED_LIBRARY,jsig) \
	)))

# regular shared libraries

$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := copy_and_sign, \
	SRC := $(OPENJ9_VM_BUILD_DIR), \
	DEST := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR)/$(OPENJ9_LIBS_SUBDIR), \
	FILES := $(patsubst %, $(call SHARED_LIBRARY,%), \
		cuda4j29 \
		j9dmp29 \
		j9jextract \
		j9gc29 \
		j9gcchk29 \
		j9hookable29 \
		j9jit29 \
		j9jnichk29 \
		j9jvm \
		j9jvmti29 \
		j9prt29 \
		j9shr29 \
		j9thr29 \
		j9trc29 \
		j9vm29 \
		j9vmchk29 \
		j9vrb29 \
		j9zlib29 \
		jclse29 \
		management \
		management_ext \
		omrsig) \
	))

ifeq (windows,$(OPENJDK_TARGET_OS))

$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := install-file, \
	SRC := $(OPENJ9_VM_BUILD_DIR)/lib, \
	DEST := $(JDK_OUTPUTDIR)/lib, \
	FILES := $(call STATIC_LIBRARY,jsig) \
	))

$(JDK_OUTPUTDIR)/lib/$(call STATIC_LIBRARY,jvm) : $(OPENJ9_VM_BUILD_DIR)/redirector/$(call STATIC_LIBRARY,redirector_jvm)
	$(install-file)

OPENJ9_STAGED_FILES += $(JDK_OUTPUTDIR)/lib/$(call STATIC_LIBRARY,jvm)

endif # windows

$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := install-file, \
	SRC := $(SRC_ROOT)/closed, \
	DEST := $(JDK_OUTPUTDIR)/lib, \
	FILES := classlib.properties \
	))

$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := install-file, \
	SRC := $(OPENJ9_VM_BUILD_DIR), \
	DEST := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR)/$(OPENJ9_LIBS_SUBDIR), \
	FILES := \
		$(notdir $(wildcard $(OUTPUT_ROOT)/vm/java*.properties)) \
		options.default \
	))

$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := install-file, \
	SRC := $(OPENJ9_VM_BUILD_DIR), \
	DEST := $(JDK_OUTPUTDIR)/lib, \
	FILES := \
		J9TraceFormat.dat \
		OMRTraceFormat.dat \
	))

ifeq (true,$(OPENJ9_ENABLE_DDR))

.PHONY : run-ddrgen

$(OPENJ9_VM_BUILD_DIR)/j9ddr.dat : run-ddrgen

run-ddrgen :
ifeq (true,$(OPENJ9_ENABLE_CMAKE))
	$(MAKE) -C $(OPENJ9_VM_BUILD_DIR) j9ddr
else # OPENJ9_ENABLE_CMAKE
	export CC="$(CC)" CXX="$(CXX)" VERSION_MAJOR=8 $(EXPORT_MSVS_ENV_VARS) \
		&& $(MAKE) -C $(OPENJ9_VM_BUILD_DIR)/ddr -f run_omrddrgen.mk
endif # OPENJ9_ENABLE_CMAKE

$(eval $(call SetupCopyFiles,OPENJ9_STAGED_FILES, \
	MACRO := install-file, \
	SRC := $(OPENJ9_VM_BUILD_DIR), \
	DEST := $(JDK_OUTPUTDIR)/$(OPENJ9_LIBS_OUTPUT_DIR)/$(OPENJ9_LIBS_SUBDIR), \
	FILES := j9ddr.dat \
	))

endif # OPENJ9_ENABLE_DDR

stage_openj9_build_jdk : $(OPENJ9_STAGED_FILES)

# openj9_copy_tree
# ----------------
# param 1 = The target directory to create or update.
# param 2 = The source directory to copy.
define openj9_copy_tree
	$(call openj9_copy_tree_impl,$(strip $(abspath $1)),$(strip $(abspath $2)))
endef

OPENJ9_MARKER_FILE := .up-to-date

# Use '-m' to update file modification times ('-m' is equivalent to '--touch' in some implementations of tar).
define openj9_copy_tree_impl
	@$(MKDIR) -p $1
	@$(TAR) --create --directory=$2 $(if $(wildcard $1/$(OPENJ9_MARKER_FILE)),--newer=$1/$(OPENJ9_MARKER_FILE)) --exclude=.git . \
		| $(TAR) --extract --directory=$1 -m
	@$(TOUCH) $1/$(OPENJ9_MARKER_FILE)
endef

OPENJ9_TEST_IMAGE_DIR := $(IMAGES_OUTPUTDIR)/test/openj9

# openj9_test_image_rules
# -----------------------
# $1 = absolute library path
define openj9_test_image_rules
openj9_test_image : $(OPENJ9_TEST_IMAGE_DIR)/$(notdir $(strip $1))
$(OPENJ9_TEST_IMAGE_DIR)/$(notdir $(strip $1)) : $(strip $1)
	$$(copy_and_sign)
endef

$(foreach file, \
	$(patsubst %, $(OPENJ9_VM_BUILD_DIR)/%$(EXE_SUFFIX), \
		algotest \
		bcvunit \
		cfdump \
		ctest \
		dyntest \
		gc_rwlocktest \
		glaunch \
		invtest \
		jsigjnitest \
		nativevmargs \
		pltest \
		propstest \
		shrtest \
		testjep178_dynamic \
		testjep178_static \
		thrstatetest \
		vmLifecyleTests \
		vmtest \
		) \
	$(patsubst %, $(OPENJ9_VM_BUILD_DIR)/$(call SHARED_LIBRARY,%), \
		balloon29 \
		bcuwhite \
		bcvrelationships \
		bcvwhite \
		gptest \
		hooktests \
		j9aixbaddep \
		j9ben \
		j9lazyClassLoad \
		j9thrnumanatives29 \
		j9thrtestnatives29 \
		j9unresolved \
		j9vmtest \
		jcoregen29 \
		jlmagent29 \
		jniargtests \
		jvmtitest \
		memorywatcher29 \
		migration \
		osmemory29 \
		SharedClassesNativeAgent \
		softmxtest \
		testjvmtiA \
		testjvmtiB \
		testlibA \
		testlibB \
		vmruntimestateagent29 \
		) \
	$(patsubst %, $(OPENJ9_VM_BUILD_DIR)/lib%.jnilib, \
		loadLibraryTest \
		), \
	$(if $(wildcard $(file)), \
		$(eval $(call openj9_test_image_rules, $(file)))))

# Comments for stage-j9
# Currently there is a staged location where j9 is built.  This is due to a number of reasons:
# 1. make currently leaves output file in current directory
# 2. generated source and header files
# 3. repo layout compared to source.zip layout
# See issue 49 for more information and actions to correct this action.

# Functions to generate sed program fragments.
# $1 - name of flag to be enabled or disabled.
SedDisable = -e '/"$(strip $1)"/s/"true"/"false"/g'
SedEnable  = -e '/"$(strip $1)"/s/"false"/"true"/g'

# Adjust features based on our configuration.
ifeq (true,$(OPENJ9_ENABLE_CUDA))
  FEATURE_SED_SCRIPT := $(call SedEnable,opt_cuda)
else
  FEATURE_SED_SCRIPT := $(call SedDisable,opt_cuda)
endif

# Function to generate sed program fragment.
# $1 - name of make macro to use instead of a hard-coded tool reference.
# $2 - suffix of uma_make_cmd property name to be adjusted.
SedUmaCommand = -e '/<property name="uma_make_cmd_$(strip $2)"/s|value="[^"]*"|value="$($(strip $1))"|'

# Copy configured values to relevant UMA properties in .spec files.
SPEC_SED_SCRIPT := \
	$(call SedUmaCommand, CC,  cc) \
	$(call SedUmaCommand, CXX, cxx) \
	$(call SedUmaCommand, CXX, interp_gcc) \
	$(call SedUmaCommand, CXX, ppc_gcc_cxx) \
	#

# Adjust DDR enablement flags.
ifeq (true,$(OPENJ9_ENABLE_DDR))
  FEATURE_SED_SCRIPT += $(call SedEnable,opt_useOmrDdr)
  SPEC_SED_SCRIPT    += $(call SedEnable,module_ddr)
else
  FEATURE_SED_SCRIPT += $(call SedDisable,opt_useOmrDdr)
  SPEC_SED_SCRIPT    += $(call SedDisable,module_ddr)
endif

# Adjust JITServer enablement flags.
ifeq (true,$(OPENJ9_ENABLE_JITSERVER))
  FEATURE_SED_SCRIPT += $(call SedEnable,build_jitserver)
else
  FEATURE_SED_SCRIPT += $(call SedDisable,build_jitserver)
endif

# openj9_stage_buildspec_file
# ---------------------------
# param 1 = The simple name of the file to copy.
define openj9_stage_buildspec_file
stage-j9 : $(OPENJ9_VM_BUILD_DIR)/buildspecs/$1
$(OPENJ9_VM_BUILD_DIR)/buildspecs/$1 : $(OPENJ9_TOPDIR)/buildspecs/$1
	@$(MKDIR) -p $$(@D)
  ifeq (.feature,$(suffix $1))
	@$(SED) $(FEATURE_SED_SCRIPT) < $$< > $$@
  else ifeq (.spec,$(suffix $1))
	@$(SED) $(SPEC_SED_SCRIPT) < $$< > $$@
  else
	@$(CP) $$< $$@
  endif
endef

$(foreach file, \
	$(notdir $(wildcard $(OPENJ9_TOPDIR)/buildspecs/*)), \
	$(eval $(call openj9_stage_buildspec_file,$(file))))

J9TOOLS_DIR := $(JDK_OUTPUTDIR)/j9tools
JPP_JAR     := $(J9TOOLS_DIR)/jpp.jar

build-openj9-tools :
	@$(ECHO) Building OpenJ9 Java Preprocessor
	@$(MKDIR) -p $(J9TOOLS_DIR)
	$(MAKE) -C $(OPENJ9_TOPDIR)/sourcetools $(MAKEFLAGS) -f buildj9tools.mk \
		BOOT_JDK=$(BOOT_JDK) \
		DEST_DIR=$(call FixPath,$(J9TOOLS_DIR)) \
		JAVA_HOME=$(BOOT_JDK) \
		$(call FixPath,$(JPP_JAR))

stage-j9 :
	@$(ECHO) Staging OpenJ9 runtime in $(OPENJ9_VM_BUILD_DIR)
	$(call openj9_copy_tree,$(OPENJ9_VM_BUILD_DIR),$(OPENJ9_TOPDIR)/runtime)

	@$(ECHO) Staging OpenJ9 OMR in $(OPENJ9_VM_BUILD_DIR)
	$(call openj9_copy_tree,$(OPENJ9_VM_BUILD_DIR)/omr,$(OPENJ9OMR_TOPDIR))

OPENJ9_VERSION_VARS := \
	COMPILER_VERSION_STRING \
	J9JDK_EXT_NAME \
	J9JDK_EXT_VERSION \
	JRE_RELEASE_VERSION \
	OPENJ9_TAG \
	OPENJ9_VERSION_STRING \
	OPENJDK_SHA \
	OPENJDK_TAG \
	OPENJDK_TARGET_CPU_BITS \
	OPENJDK_TARGET_CPU_OSARCH \
	OPENJDK_TARGET_OS \
	PRODUCT_NAME \
	USERNAME \
	#

OPENJ9_VERSION_SCRIPT := \
	$(foreach var,$(OPENJ9_VERSION_VARS),-e 's|@$(var)@|$(value $(var))|g')

# create_or_update
# ----------------
# Create a file or update it if necessary.
# --
# param 1 = command yielding desired content to stdout
# param 2 = file to be created or updated
define create_or_update
	@$(MKDIR) -p $(dir $2)
	$1 > $2.tmp
	@if [ -f $2 ] && $(DIFF) -q $2 $2.tmp > /dev/null ; then \
		$(RM) $2.tmp ; \
	else \
		$(MV) $2.tmp $2 ; \
	fi
endef

CUSTOM_COMPILER_ENV_VARS :=

ifneq (,$(OPENJ9_CC))
  CUSTOM_COMPILER_ENV_VARS += CC="$(OPENJ9_CC)"
endif
ifneq (,$(OPENJ9_CXX))
  CUSTOM_COMPILER_ENV_VARS += CXX="$(OPENJ9_CXX)"
endif
ifneq (,$(OPENJ9_DEVELOPER_DIR))
  CUSTOM_COMPILER_ENV_VARS += DEVELOPER_DIR="$(OPENJ9_DEVELOPER_DIR)"
endif

generate-j9-version-headers :
	@$(ECHO) Ensuring version information is up-to-date
	$(call create_or_update, \
		$(ECHO) '#define OMR_VERSION_STRING "$(OPENJ9OMR_SHA)"', \
		$(OPENJ9_VM_BUILD_DIR)/omr/OMR_VERSION_STRING)
	$(call create_or_update, \
		$(ECHO) '#define TR_LEVEL_NAME "$(OPENJ9_SHA)"', \
		$(OPENJ9_VM_BUILD_DIR)/compiler/jit.version)
	$(call create_or_update, \
		@$(SED) $(OPENJ9_VERSION_SCRIPT) < $(SRC_ROOT)/closed/openj9_version_info.h.in, \
		$(OPENJ9_VM_BUILD_DIR)/include/openj9_version_info.h)

ifeq (true,$(OPENJ9_ENABLE_CMAKE))
CMAKE_ARGS := \
	-C $(OPENJ9_TOPDIR)/runtime/cmake/caches/$(OPENJ9_BUILDSPEC).cmake \
	-DBOOT_JDK=$(BOOT_JDK) \
	-DJ9VM_OMR_DIR=$(OPENJ9OMR_TOPDIR) \
	-DBUILD_ID=$(BUILD_ID) \
	-DJAVA_SPEC_VERSION=8 \
	-DOPENJ9_BUILD=true

# We grab the C/C++ compilers detected by autoconf or provided by user, not
# the CC/CXX variables defined by the makefiles, which potentially include
# the ccache command which will throw off cmake.
ifneq (,$(OPENJ9_CC))
  CMAKE_ARGS += -DCMAKE_C_COMPILER="$(OPENJ9_CC)"
else
  CMAKE_ARGS += -DCMAKE_C_COMPILER="$(ac_cv_prog_CC)"
endif

ifneq (,$(OPENJ9_CXX))
  CMAKE_ARGS += -DCMAKE_CXX_COMPILER="$(OPENJ9_CXX)"
else
  CMAKE_ARGS += -DCMAKE_CXX_COMPILER="$(ac_cv_prog_CXX)"
endif

ifeq (true,$(OPENJ9_ENABLE_CUDA))
  CMAKE_ARGS += -DJ9VM_OPT_CUDA=ON
  CMAKE_CUDA_ENV := CUDA_BIN_PATH="$(CUDA_HOME)"
else
  CMAKE_ARGS += -DJ9VM_OPT_CUDA=OFF
  CMAKE_CUDA_ENV :=
endif # OPENJ9_ENABLE_CUDA

ifeq (true,$(OPENJ9_ENABLE_DDR))
  CMAKE_ARGS += -DOMR_DDR=ON
else
  CMAKE_ARGS += -DOMR_DDR=OFF
endif # OPENJ9_ENABLE_DDR

ifneq (,$(CCACHE))
  # openjdk makefiles adds a bunch of environemnt variables to the ccache command.
  # CMake will not parse this properly, so we wrap the whole thing in the env command.
  # We also need to add semicolons between arguments or else cmake will treat the whole
  # thing as one long command name.

  # Note: we remove the CCACHE_COMPRESS option that openjdk adds, because it significantly
  # slows down the build (to the point of erasing any gains from using ccache).
  CCACHE_NOCOMPRESS := $(filter-out CCACHE_COMPRESS=1,$(CCACHE))
  ESCAPED_CCACHE := env$(subst $(SPACE),,$(addprefix ;,$(CCACHE_NOCOMPRESS)))

  CMAKE_ARGS += "-DCMAKE_CXX_COMPILER_LAUNCHER=$(ESCAPED_CCACHE)"
  CMAKE_ARGS += "-DCMAKE_C_COMPILER_LAUNCHER=$(ESCAPED_CCACHE)"
endif # CCACHE

ifeq (true,$(OPENJ9_ENABLE_JITSERVER))
  CMAKE_ARGS += -DJITSERVER_SUPPORT=ON

  ifneq (,$(OPENSSL_CFLAGS))
    CMAKE_ARGS += -DOPENSSL_CFLAGS="$(OPENSSL_CFLAGS)"
  endif

  ifneq (,$(OPENSSL_DIR))
    CMAKE_ARGS += -DOPENSSL_DIR="$(OPENSSL_DIR)"
  endif

  ifneq (,$(OPENSSL_BUNDLE_LIB_PATH))
    CMAKE_ARGS += -DOPENSSL_BUNDLE_LIB_PATH="$(OPENSSL_BUNDLE_LIB_PATH)"
  endif
else
  CMAKE_ARGS += -DJITSERVER_SUPPORT=OFF
endif # OPENJ9_ENABLE_JITSERVER

  CMAKE_ARGS += $(EXTRA_CMAKE_ARGS)

$(OUTPUT_ROOT)/vm/cmake.stamp :
	@$(MKDIR) -p $(@D)
	cd $(@D) && $(CMAKE_CUDA_ENV) $(CMAKE) $(CMAKE_ARGS) $(OPENJ9_TOPDIR)
	$(TOUCH) $@

run-preprocessors-j9 : $(OUTPUT_ROOT)/vm/cmake.stamp

else # OPENJ9_ENABLE_CMAKE

ifeq (true,$(OPENJ9_ENABLE_JITSERVER))
  CUSTOM_COMPILER_ENV_VARS += JITSERVER_SUPPORT=1

  ifneq (,$(OPENSSL_CFLAGS))
    CUSTOM_COMPILER_ENV_VARS += OPENSSL_CFLAGS="$(OPENSSL_CFLAGS)"
  endif

  ifneq (,$(OPENSSL_DIR))
    CUSTOM_COMPILER_ENV_VARS += OPENSSL_DIR="$(OPENSSL_DIR)"
  endif

  ifneq (,$(OPENSSL_BUNDLE_LIB_PATH))
    CUSTOM_COMPILER_ENV_VARS += OPENSSL_BUNDLE_LIB_PATH="$(OPENSSL_BUNDLE_LIB_PATH)"
  endif
endif # OPENJ9_ENABLE_JITSERVER

run-preprocessors-j9 : stage-j9
	@$(ECHO) Running OpenJ9 preprocessors with OPENJ9_BUILDSPEC: $(OPENJ9_BUILDSPEC)
	@$(MKDIR) -p $(J9TOOLS_DIR)
	export $(EXPORT_MSVS_ENV_VARS) \
		OPENJDK_VERSION_NUMBER_FOUR_POSITIONS=$(VERSION_NUMBER_FOUR_POSITIONS) \
		&& $(MAKE) -C $(OUTPUT_ROOT)/vm $(MAKEFLAGS) -f $(OPENJ9_TOPDIR)/runtime/buildtools.mk \
			BOOT_JDK=$(BOOT_JDK) \
			BUILD_ID=$(BUILD_ID) \
			DEST_DIR=$(call FixPath,$(J9TOOLS_DIR)) \
			FREEMARKER_JAR="$(FREEMARKER_JAR)" \
			J9VM_SHA=$(OPENJ9_SHA) \
			JAVA_HOME=$(BOOT_JDK) \
			JAVA_VERSION=80 \
			OMR_DIR=$(OPENJ9_VM_BUILD_DIR)/omr \
			SOURCETOOLS_DIR=$(call FixPath,$(OPENJ9_TOPDIR))/sourcetools \
			SPEC=$(OPENJ9_BUILDSPEC) \
			UMA_OPTIONS_EXTRA="-buildDate $(shell date +'%Y%m%d')" \
			VERSION_MAJOR=8 \
			tools

endif # OPENJ9_ENABLE_CMAKE

run-preprocessors-j9 : generate-j9-version-headers

build-j9 : run-preprocessors-j9
	@$(ECHO) Compiling OpenJ9 in $(OPENJ9_VM_BUILD_DIR)
	export OPENJ9_BUILD=true $(EXPORT_MSVS_ENV_VARS) $(CUSTOM_COMPILER_ENV_VARS) \
		&& $(MAKE) -C $(OUTPUT_ROOT)/vm $(MAKEFLAGS) JAVA_VERSION=80 VERSION_MAJOR=8 all
	@$(ECHO) OpenJ9 compile complete
	@$(MKDIR) -p $(JDK_IMAGE_DIR)/
	@$(MKDIR) -p $(JRE_IMAGE_DIR)/
	@$(CP) -p $(SRC_ROOT)/$(OPENJ9_NOTICE_FILE) $(JDK_IMAGE_DIR)/$(OPENJ9_NOTICE_FILE_RENAME)
	@$(CP) -p $(SRC_ROOT)/$(OPENJ9_NOTICE_FILE) $(JRE_IMAGE_DIR)/$(OPENJ9_NOTICE_FILE_RENAME)
	@$(CP) -p $(SRC_ROOT)/$(OPENJ9_OPENJDK_NOTICE_FILE) $(JDK_IMAGE_DIR)/$(OPENJ9_OPENJDK_NOTICE_FILE)
	@$(CP) -p $(SRC_ROOT)/$(OPENJ9_OPENJDK_NOTICE_FILE) $(JRE_IMAGE_DIR)/$(OPENJ9_OPENJDK_NOTICE_FILE)

J9JCL_SOURCES_DONEFILE := $(JDK_OUTPUTDIR)/j9jcl_sources/j9jcl_sources.done

recur_wildcard = $(foreach dir,$(wildcard $1/*),$(call recur_wildcard,$(dir),$2) $(filter $(subst *,%,$2),$(dir)))
AllJclSource   = $(call recur_wildcard,$(OPENJ9_TOPDIR)/jcl/src,*.java)

JPP_DEST := $(JDK_OUTPUTDIR)/j9jcl_sources/jdk/src/share/classes

$(J9JCL_SOURCES_DONEFILE) : $(AllJclSource)
	@$(ECHO) Generating J9JCL sources
	$(BOOT_JDK)/bin/java \
		-cp "$(call FixPath,$(JPP_JAR))" \
		-Dfile.encoding=US-ASCII \
		com.ibm.jpp.commandline.CommandlineBuilder \
			-verdict \
			-baseDir "$(call FixPath,$(OPENJ9_TOPDIR))/" \
			-config SIDECAR18-SE-OPENJ9 \
			-srcRoot jcl/ \
			-xml jpp_configuration.xml \
			-dest "$(call FixPath,$(JPP_DEST))" \
			-macro:define "com.ibm.oti.vm.library.version=29" \
			-tag:define "PLATFORM-$(OPENJ9_PLATFORM_CODE)"
	@$(ECHO) Generating J9JCL tools
	@$(BOOT_JDK)/bin/java \
		-cp "$(call FixPath,$(JPP_JAR))" \
		-Dfile.encoding=US-ASCII \
		com.ibm.jpp.commandline.CommandlineBuilder \
			-verdict \
			-baseDir "$(call FixPath,$(OPENJ9_TOPDIR))/" \
			-config SIDECAR18-TOOLS-OPENJ9 \
			-srcRoot jcl/ \
			-xml jpp_configuration.xml \
			-dest "$(call FixPath,$(JPP_DEST))" \
			-macro:define "com.ibm.oti.vm.library.version=29" \
			-tag:define "PLATFORM-$(OPENJ9_PLATFORM_CODE)"
	@$(MKDIR) -p $(@D)
	@$(TOUCH) $@

generate-j9jcl-sources : $(J9JCL_SOURCES_DONEFILE)

clean-j9 : clean-openj9-thirdparty-binaries
	(cd $(OUTPUT_ROOT)/vm && $(MAKE) clean)

clean-j9-dist : clean-openj9-thirdparty-binaries
	$(RM) -fdr $(OUTPUT_ROOT)/vm

clean-openj9-thirdparty-binaries :
	$(RM) -f $(OPENJ9_STAGED_THIRDPARTY_BINARIES) $(patsubst %.jar,%.tar.gz,$(OPENJ9_STAGED_THIRDPARTY_BINARIES))
